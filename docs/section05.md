# API 개발 고급 - 실무 필수 최적화

## OSIV

하이버네이트에서는 Open Session In View, JPA에서는 Open EntityManager In View 이나 관례상 OSIV라 한다.  
`spring.jpa.open-in-view` 에서 기본값은 true이다.  

![image](https://github.com/yeondori/yeondori.github.io/assets/93027942/08f812dd-37e9-44cd-8e6e-0ea5b7551d6a)

JPA는 기본적으로 데이터베이스 트랜젝션을 시작할 때, 영속성 컨텍스트에서 데이터베이스 커넥션을 가져온다.   
OSIV가 켜져있다면 트랜잭션이 끝나도 영속성 컨텍스트를 살려둔다. API의 경우 API가 반환될 때까지, 화면의 경우 뷰 템플릿이 렌더링되는 등 유저에게 Response가 나갈 때까지 가지고 있게 된다.

지연 로딩은 영속성 컨텍스트가 살아있어야 가능하고, 영속성 컨텍스트는 데이터 베이스 커넥션을 유지하므로 큰 장점이지만 큰 단점이기도 하다.
너무 오랜 시간동안 데이터베이스 커넥션 리소스를 사용하는 것이 실시간 트래픽이 중요한 경우에는 장애로 이어질 수 있기 때문이다.

![image](https://github.com/yeondori/yeondori.github.io/assets/93027942/9fc9f687-6e7b-4ed6-a48b-84b9e011c2f6)

옵션을 끄게 되면 트랜잭션이 시작되고 끝날 때까지만 데이터베이스 커넥션을 유지하고, 트랜잭션이 종료되면 영속성 컨텍스트를 닫고 커넥션을 반환한다.    
데이터베이스 커넥션을 짧은 기간 동안 유지한다는 장점이 있으나 모든 지연 로딩을 트랜잭션 안에서 처리해야 한다는 단점이 있다.   
즉, 트랜잭션이 끝나기 전에 지연 로딩을 강제로 호출해두어야 한다.

이를 구조적으로 해결하기 위한 방법들은 다음과 같다.

### 커맨드와 쿼리 분리
OSIV를 끈 상태로 복잡성을 관리하는 방법 중 하나다.  
보통의 성능 이슈는 조회에서 발생한다. 
핵심 비즈니스 로직과 화면의 라이프 사이클이 다르므로 유지보수 관점에서 관심사를 명확히 분리하는 것이 좋다.

예를 들어, 화면이나 API에 맞춘 서비스를 OrderQueryService 와 같은 방식으로 핵심 비즈니스 로직과 분리한다.  

참고로 강사님의 경우는 트래픽이 많은 고객 서비스 같은 경우는 OSIV를 끄고, ADMIN 처럼 커넥션을 많이 사용하지 않는 곳에서는 OSIV를 켜신다고 한다!